// Generated by CoffeeScript 1.9.3
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.World = (function() {
    function World(normalized_position, map_size) {
      this.map_size = map_size;
      this.end_scene = bind(this.end_scene, this);
      this.draw = bind(this.draw, this);
      this.load_tile = bind(this.load_tile, this);
      this.load_image = bind(this.load_image, this);
      this.get_position_in_world = bind(this.get_position_in_world, this);
      this.flash_overlay = bind(this.flash_overlay, this);
      this.shake = bind(this.shake, this);
      this.scroll_to_position = bind(this.scroll_to_position, this);
      this.keep_stickman_in_view = bind(this.keep_stickman_in_view, this);
      this.load_current_scene = bind(this.load_current_scene, this);
      this.normalized_map_coords = bind(this.normalized_map_coords, this);
      this.unnormalized_map_coords = bind(this.unnormalized_map_coords, this);
      this.load = bind(this.load, this);
      this.save = bind(this.save, this);
      this.toggle_pause = bind(this.toggle_pause, this);
      this.resume = bind(this.resume, this);
      this.pause = bind(this.pause, this);
      this.position = [normalized_position[0] * this.map_size[0], normalized_position[1] * this.map_size[1]];
      this.images = {};
      this.scale = 0.25;
      this.canvas_id = 'stickman-canvas';
      this.canvas = document.getElementById(this.canvas_id);
      this.context = this.canvas.getContext("2d");
      this.keeping_stickman_in_view = true;
    }

    World.prototype.MAX_COLLISION_COUNT = 25;

    World.prototype.image_data = void 0;

    World.prototype.original_tilesize = void 0;

    World.prototype.scale = void 0;

    World.prototype.bool_empty_space = false;

    World.prototype.centre = [0, 0];

    World.prototype.centre_last = [-1, -1];

    World.prototype.t_name = void 0;

    World.prototype.t_number = void 0;

    World.prototype.scene = void 0;

    World.prototype.map_size = void 0;

    World.prototype.cur_tile_name = '';

    World.prototype.cur_x_tile = 1;

    World.prototype.cur_y_tile = 1;

    World.prototype.theme_song = new Howl({
      src: ['sounds/theme_song.mp3'],
      volume: 0.1,
      html5: true
    });

    World.prototype.pause = function() {
      return this.paused = true;
    };

    World.prototype.resume = function() {
      this.paused = false;
      requestAnimationFrame(updateWorld);
      if (this.sound_on && !this.theme_song.is_playing) {
        this.theme_song.play();
        return this.theme_song.is_playing = true;
      }
    };

    World.prototype.toggle_pause = function() {
      if (this.paused) {
        return this.resume();
      } else {
        return this.pause();
      }
    };

    World.prototype.save = function() {
      var creatures_json, stickman_json, tile_animations_json;
      stickman_json = stickman.toJSON();
      creatures_json = creatures.map((function(_this) {
        return function(creature) {
          return creature.toJSON();
        };
      })(this));
      tile_animations_json = {};
      Object.keys(tile_animations).map((function(_this) {
        return function(key) {
          return tile_animations_json[key] = {
            triggered: tile_animations[key].triggered
          };
        };
      })(this));
      localforage.setItem('stickman', stickman_json);
      localforage.setItem('creatures', creatures_json);
      return localforage.setItem('tile_animations', tile_animations_json);
    };

    World.prototype.load = function() {
      var cnames, p1, p2, p3, p4;
      p1 = localforage.getItem('stickman');
      p2 = localforage.getItem('creatures');
      p3 = localforage.getItem('tile_animations');
      p4 = localforage.getItem('images');
      cnames = {
        'mushroom_man': MushroomMan
      };
      return Promise.all([p1, p2, p3, p4]).then((function(_this) {
        return function(values) {
          var creatures_json, old_stickman, stickman_json, tile_animations_json;
          stickman_json = values[0];
          creatures_json = values[1];
          tile_animations_json = values[2];
          Object.keys(tile_animations_json).map(function(key) {
            return tile_animations[key].triggered = tile_animations_json[key].triggered;
          });
          window.creatures = creatures_json.map(function(c) {
            var callback, creature, tilenumber, type;
            if (c.name === 'explosion') {
              return void 0;
            }
            type = cnames[c.name];
            if (!type) {
              type = window[c.name[0].toUpperCase() + c.name.substr(1)];
            }
            creature = new type(c.position);
            if (c.name === 'bowser') {
              window.bowser = creature;
            }
            if (c.name === 'bomb') {
              creature = new type(c.position, c.is_dud);
              if (!c.is_dud) {
                creature.has_exploded = true;
                tilenumber = tile_number_abs(creature.position, creature.tilesize);
                callback = function() {
                  return setTimeout(function() {
                    return creature.explode(true);
                  }, 100);
                };
                creature.load_image(callback, tilenumber[0], tilenumber[1]);
              }
            }
            if (c.name === 'crater') {
              creature = new type(c.position, c.blast_radius, false);
            }
            if (c.name === 'pipe') {
              creature.teleport_position = c.teleport_position;
            }
            return creature;
          }).filter(function(c) {
            return c;
          });
          old_stickman = window.stickman;
          window.stickman = new Stickman(stickman_json.position);
          if (stickman_json.has_bomb) {
            stickman.enable_bomb();
          }
          if (stickman_json.has_fire) {
            stickman.enable_fire();
          }
          window.stickman.score = stickman_json.score;
          return window.stickman.coins_collected = stickman_json.coins_collected;
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          return console.warn(err);
        };
      })(this));
    };

    World.prototype.unnormalized_map_coords = function(normalized_position) {
      return [normalized_position[0] * this.map_size[0], normalized_position[1] * this.map_size[1]];
    };

    World.prototype.normalized_map_coords = function(unnormalized_position) {
      return [unnormalized_position[0] * 1.0 / this.map_size[0], unnormalized_position[1] * 1.0 / this.map_size[1]];
    };

    World.prototype.load_current_scene = function() {
      var i, len, name, results, tile, x, xrange, y, yrange;
      this.centre_last = this.centre;
      this.centre = [Math.floor(-this.position[0] / this.tilesize), Math.floor(-this.position[1] / this.tilesize)];
      xrange = [-1, 0, 1];
      yrange = [-1, 0, 1];
      results = [];
      for (i = 0, len = yrange.length; i < len; i++) {
        y = yrange[i];
        results.push((function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = xrange.length; j < len1; j++) {
            x = xrange[j];
            name = tile_name2(this.centre[0] + x, this.centre[1] + y);
            tile = this.images[name];
            if (!tile) {
              results1.push(this.load_tile(this.centre[0] + x, this.centre[1] + y));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    World.prototype.keep_stickman_in_view = function(player_position, screen_width, screen_height) {
      var BORDER_BOTTOM, BORDER_LEFT, BORDER_RIGHT, BORDER_TOP, x, y;
      if (!this.keeping_stickman_in_view) {
        return;
      }
      BORDER_LEFT = screen_width / 2 - screen_width / 6;
      BORDER_RIGHT = screen_width / 2 + screen_width / 6;
      BORDER_TOP = screen_height / 2 - screen_height / 6;
      BORDER_BOTTOM = screen_height / 2 + screen_height / 6;
      x = this.position[0] - player_position[0];
      y = this.position[1] - player_position[1];
      if (x > BORDER_RIGHT) {
        this.position[0] -= x - BORDER_RIGHT;
        x = BORDER_RIGHT;
      } else if (x < BORDER_LEFT) {
        this.position[0] -= x - BORDER_LEFT;
        x = BORDER_LEFT;
      }
      if (y > BORDER_BOTTOM) {
        this.position[1] -= y - BORDER_BOTTOM;
        y = BORDER_BOTTOM;
      } else if (y < BORDER_TOP) {
        this.position[1] -= y - BORDER_TOP;
        y = BORDER_TOP;
      }
      return 0;
    };

    World.prototype.scroll_to_position = function(position, callback, scroll_factor, num_scrolls, max_num_scrolls) {
      var d, new_position;
      if (callback == null) {
        callback = void 0;
      }
      if (scroll_factor == null) {
        scroll_factor = 0.2;
      }
      if (num_scrolls == null) {
        num_scrolls = 0;
      }
      if (max_num_scrolls == null) {
        max_num_scrolls = 200;
      }
      d = distance_between_points(position, this.position);
      if (d > 10 && num_scrolls < max_num_scrolls) {
        new_position = [this.position[0] + (position[0] - this.position[0]) * scroll_factor, this.position[1] + (position[1] - this.position[1]) * scroll_factor];
        this.position = new_position;
        return setTimeout((function(_this) {
          return function() {
            return _this.scroll_to_position(position, callback, scroll_factor, num_scrolls + 1, max_num_scrolls);
          };
        })(this), 15);
      } else {
        if (num_scrolls > max_num_scrolls) {
          console.info("exceed max scrolls");
        }
        return callback && callback();
      }
    };

    World.prototype.shake = function(callback) {
      var promise, px, py, r, ref, scroll_factor;
      if (callback == null) {
        callback = void 0;
      }
      ref = this.position, px = ref[0], py = ref[1];
      this.keeping_stickman_in_view = false;
      r = 100;
      scroll_factor = 1;
      return promise = new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.scroll_to_position([px - r, py - r], function() {
            resolve('scroll finished');
          }, scroll_factor);
        };
      })(this)).then((function(_this) {
        return function(res) {
          promise = new Promise(function(resolve, reject) {
            return _this.scroll_to_position([px + r, py + r], function() {
              resolve('scroll finished');
            }, scroll_factor);
          });
          return promise;
        };
      })(this)).then((function(_this) {
        return function(res) {
          promise = new Promise(function(resolve, reject) {
            return _this.scroll_to_position([px - r, py - 0], function() {
              resolve('scroll finished');
            }, scroll_factor);
          });
          return promise;
        };
      })(this)).then((function(_this) {
        return function(res) {
          promise = new Promise(function(resolve, reject) {
            return _this.scroll_to_position([px - r, py - r], function() {
              resolve('scroll finished');
            }, scroll_factor);
          });
          return promise;
        };
      })(this)).then((function(_this) {
        return function(res) {
          promise = new Promise(function(resolve, reject) {
            return _this.scroll_to_position([px - r, py + r], function() {
              resolve('scroll finished');
            }, scroll_factor);
          });
          return promise;
        };
      })(this)).then((function(_this) {
        return function(res) {
          _this.keeping_stickman_in_view = true;
          return callback && callback();
        };
      })(this));
    };

    World.prototype.flash_overlay = function(overlay, num_frames) {
      if (overlay == null) {
        overlay = void 0;
      }
      if (num_frames == null) {
        num_frames = 10;
      }
      this.has_overlay = true;
      this.overlay_frame_counter = 0;
      this.overlay_num_frames = num_frames;
      if (overlay) {
        return this.overlay = overlay;
      } else {
        return this.overlay = ((function(_this) {
          return function(tile) {
            console.warn("provide overlay function");
            return _this.has_overlay = false;
          };
        })(this));
      }
    };

    World.prototype.get_position_in_world = function(position_on_screen) {
      var abs_coords;
      abs_coords = [this.position[0] - position_on_screen[0], this.position[1] - position_on_screen[1]];
      return this.normalized_map_coords(abs_coords);
    };

    World.prototype.load_image = function(x_tile, y_tile, callback) {
      var name, tile;
      name = tile_name2(x_tile, y_tile);
      tile = this.images[name];
      if (!(tile && tile.image_data)) {
        return this.load_tile(x_tile, y_tile, callback);
      } else {
        return callback && callback(tile);
      }
    };

    World.prototype.load_tile = function(x, y, callback) {
      var img, left, name, top;
      name = tile_name2(x, y);
      left = x * this.tilesize;
      top = y * this.tilesize;
      this.images[name] = {
        name: name,
        left: left,
        top: top
      };
      img = new Image();
      img.onload = (function(_this) {
        return function() {
          if (!(_this.images[name] && _this.images[name].canvas)) {
            _this.scene_canvas = document.createElement("canvas");
            _this.scene_canvas.width = img.width * _this.scale;
            _this.scene_canvas.height = img.height * _this.scale;
            _this.scene_context = _this.scene_canvas.getContext("2d");
            _this.scene_context.scale(_this.scale, _this.scale);
            _this.scene_context.drawImage(img, 0, 0);
            _this.image_data = _this.scene_context.getImageData(0, 0, img.width * _this.scale, img.height * _this.scale);
            _this.images[name] = {
              name: name,
              dom: img,
              left: left,
              top: top,
              image_data: _this.image_data,
              canvas: _this.scene_canvas
            };
          }
          return callback && callback(_this.images[name]);
        };
      })(this);
      img.onerror = (function(_this) {
        return function(e) {
          console.info("ERROR LOADING IMAGE");
          _this.scene_canvas = document.createElement("canvas");
          _this.scene_canvas.width = 2048 * _this.scale;
          _this.scene_canvas.height = 2048 * _this.scale;
          _this.scene_context = _this.scene_canvas.getContext("2d");
          _this.scene_context.rect(0, 0, _this.scene_canvas.width, _this.scene_canvas.height);
          _this.scene_context.fillStyle = 'red';
          _this.scene_context.fill();
          _this.image_data = _this.scene_context.getImageData(0, 0, _this.scene_canvas.width, _this.scene_canvas.height);
          _this.images[name] = {
            name: name,
            left: left,
            top: top,
            image_data: _this.image_data,
            canvas: _this.scene_canvas
          };
          return callback && callback(_this.images[name]);
        };
      })(this);
      if (file_hash[name]) {
        return img.src = './xkcd_grab/' + name + '.png';
      } else {
        if (name.match(/\dn/)) {
          return img.src = './xkcd_grab/' + 'white.png';
        } else {
          return img.src = './xkcd_grab/' + 'black.png';
        }
      }
    };

    World.prototype.draw = function() {
      var i, len, name, results, tile, x, xrange, y, yrange;
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      xrange = [-1, 0, 1];
      yrange = [-1, 0, 1];
      results = [];
      for (i = 0, len = yrange.length; i < len; i++) {
        y = yrange[i];
        results.push((function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = xrange.length; j < len1; j++) {
            x = xrange[j];
            name = tile_name2(this.centre[0] + x, this.centre[1] + y);
            tile = this.images[name];
            if (tile) {
              if (tile.dom) {
                this.context.drawImage(tile.dom, this.position[0] + tile.left, this.position[1] + tile.top, this.tilesize, this.tilesize);
                if (this.borders) {
                  this.context.beginPath();
                  this.context.strokeStyle = 'green';
                  this.context.rect(this.position[0] + tile.left, this.position[1] + tile.top, this.tilesize, this.tilesize);
                  this.context.stroke();
                }
                if (this.has_overlay) {
                  results1.push(this.overlay(tile));
                } else {
                  results1.push(void 0);
                }
              } else {
                results1.push(void 0);
              }
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    World.prototype.end_scene = function() {
      var bomb, old_position, promise;
      this.keeping_stickman_in_view = false;
      old_position = this.position;
      bomb = void 0;
      promise = new Promise((function(_this) {
        return function(resolve, reject) {
          _this.scroll_to_position([-244000, -82869], (function() {
            resolve('scroll finished');
          }), 0.2, 0, 500);
        };
      })(this));
      -244000;
      return promise.then((function(_this) {
        return function(res) {
          cage.is_moving_left = true;
          promise = new Promise(function(resolve, reject) {
            return setTimeout((function() {
              cage.die();
              creatures.unshift(cage);
              princess.player_speed = 1;
              princess.is_moving_right = true;
              stickman.change_score(1000);
              return resolve('scene finished');
            }), 2000);
          });
          return promise;
        };
      })(this)).then((function(_this) {
        return function(res) {
          promise = new Promise(function(resolve, reject) {
            return setTimeout((function() {
              return resolve('delay finished');
            }), 5000);
          });
          return promise;
        };
      })(this)).then((function(_this) {
        return function(res) {
          return promise = new Promise(function(resolve, reject) {
            _this.scroll_to_position(old_position, (function() {
              resolve('last scroll finished');
            }), 0.2, 0, 500);
          });
        };
      })(this)).then(function(res) {
        return world.keeping_stickman_in_view = true;
      });
    };

    return World;

  })();

}).call(this);
